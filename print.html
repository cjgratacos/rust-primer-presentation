<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Primer</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="rust.html"><strong aria-hidden="true">2.</strong> Rust</a></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">3.</strong> Tooling</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">4.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">5.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="ownership_borrowing.html"><strong aria-hidden="true">6.</strong> Ownership & Borrowing</a></li><li class="chapter-item expanded "><a href="memory.html"><strong aria-hidden="true">7.</strong> Memory</a></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">8.</strong> Structs</a></li><li class="chapter-item expanded "><a href="enums_and_patterns.html"><strong aria-hidden="true">9.</strong> Enums and Pattern Matching</a></li><li class="chapter-item expanded "><a href="traits_generics_lifetime.html"><strong aria-hidden="true">10.</strong> Traits, Generics and Lifetime</a></li><li class="chapter-item expanded "><a href="functional_features.html"><strong aria-hidden="true">11.</strong> Functional Language Features</a></li><li class="chapter-item expanded "><a href="collections.html"><strong aria-hidden="true">12.</strong> Collections</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">13.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="smart_pointer.html"><strong aria-hidden="true">14.</strong> Smart Pointer</a></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">15.</strong> Macros</a></li><li class="chapter-item expanded "><a href="tests.html"><strong aria-hidden="true">16.</strong> Tests</a></li><li class="chapter-item expanded "><a href="module_crates_packages.html"><strong aria-hidden="true">17.</strong> Module, Crates and Packages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Primer</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-primer"><a class="header" href="#rust-primer">Rust Primer</a></h1>
<p><img src="./imgs/rustacean-orig-noshadow.svg" alt="Ferris!" /></p>
<h2 id="what-is-rust"><a class="header" href="#what-is-rust">What is Rust?</a></h2>
<p>According to Wikipedia, Rust is a:</p>
<ul>
<li>multi-paradigm</li>
<li>high-level</li>
<li>general-purpose programming language</li>
<li>emphasize on: 
<ul>
<li>performance</li>
<li>type safety </li>
<li>concurrency </li>
</ul>
</li>
<li>enforces memory safety—that is, that all references point to valid memory—without requiring the use of a garbage collector or reference counting present in other memory-safe languages</li>
<li>to simultaneously enforce memory safety and prevent concurrent data races, Rust's &quot;borrow checker&quot; tracks the object lifetime of all references in a program during compilation </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p>Web page: <a href="https://www.rust-lang.org/">https://www.rust-lang.org/</a></p>
<p>Installing: <a href="https://www.rust-lang.org/learn/get-started">https://www.rust-lang.org/learn/get-started</a></p>
<h2 id="resources"><a class="header" href="#resources">Resources:</a></h2>
<ul>
<li>Learn: <a href="https://www.rust-lang.org/learn">https://www.rust-lang.org/learn</a></li>
<li>Rust official book: <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a></li>
<li>Rustling project: <a href="https://github.com/rust-lang/rustlings/">https://github.com/rust-lang/rustlings/</a></li>
<li>Rust by example: <a href="https://doc.rust-lang.org/stable/rust-by-example/">https://doc.rust-lang.org/stable/rust-by-example/</a></li>
<li>Rust Youtube: <a href="https://www.youtube.com/channel/UCaYhcUwRBNscFNUKTjgPFiA">https://www.youtube.com/channel/UCaYhcUwRBNscFNUKTjgPFiA</a></li>
</ul>
<h2 id="books-that-i-recommend"><a class="header" href="#books-that-i-recommend">Books that I recommend:</a></h2>
<ul>
<li><a href="https://www.amazon.com/Rust-Action-TS-McNamara/dp/1617294551">Rust in Action</a></li>
<li><a href="https://www.amazon.com/Rust-Programming-Language-2nd/dp/1718503105">The Rust Programming Language, 2nd Edition</a></li>
<li><a href="https://www.amazon.com/Rust-Rustaceans-Programming-Experienced-Developers/dp/1718501854">Rust for Rustaceans: Idiomatic Programming for Experienced Developers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tooling"><a class="header" href="#tooling">Tooling</a></h1>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p>Cargo is the Rust package manager.
Cargo:</p>
<ul>
<li>Downloads your Rust package's dependencies.</li>
<li>Compiles your packages.</li>
<li>Makes distributable packages.</li>
<li>Uploads them to crates.io (the Rust community’s package registry)</li>
</ul>
<p>Example of commads:</p>
<pre><code class="language-sh"># Create project
$ cargo new hello_world

# Build project
$ cargo build

# Run project
$ cargo run

# Test project
$ cargo test

</code></pre>
<h2 id="cratesio"><a class="header" href="#cratesio">Crates.io</a></h2>
<p>The community's rust package (create) registry.
<a href="https://crates.io/">https://crates.io/</a></p>
<h2 id="docsrs"><a class="header" href="#docsrs">Docs.rs</a></h2>
<p>The community's open source documentation for crates.
<a href="https://docs.rs/">https://docs.rs/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>Like any other Programing language, the first step of learning is how to do a Hello world.</p>
<pre><code class="language-sh">$ cargo new hello_world
$ cd hello_world

</code></pre>
<p>The project structure:</p>
<pre><code class="language-sh">.
├── Cargo.toml
└── src
    └── main.rs

</code></pre>
<pre><code class="language-sh">$ cargo run
   Compiling hello_world v0.1.0
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/hello_world`
Hello, world!

</code></pre>
<pre><pre class="playground"><code class="language-rust">// ./src/main.rs
fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<h2 id="variables-and-mutability"><a class="header" href="#variables-and-mutability">Variables and Mutability</a></h2>
<ul>
<li>By default in Rust all variables are immutable unless explicitly configured.</li>
<li>Immutable variables cannot be changed onced created.</li>
</ul>
<pre><pre class="playground"><code class="language-rust should_panic editable">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {x}&quot;);
    x = 6;
    println!(&quot;The value of x is: {x}&quot;);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {x}&quot;);
    x = 6;
    println!(&quot;The value of x is: {x}&quot;);
}</code></pre></pre>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<ul>
<li>No mut.</li>
<li>Always immutable.</li>
<li>Use <code>const</code> keyword.</li>
<li>Type must be annotated.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;

<span class="boring">}</span></code></pre></pre>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;The value of x in the inner scope is: {x}&quot;);
    }

    println!(&quot;The value of x is: {x}&quot;);
}</code></pre></pre>
<h2 id="data-types"><a class="header" href="#data-types">Data Types</a></h2>
<ul>
<li>Integer Types:
<ul>
<li>8 bit: i8,u8</li>
<li>16 bit: i16,u16</li>
<li>32 bit: i32,u32</li>
<li>64 bit: i64,u64</li>
<li>128 bit: i128,u128</li>
<li>arch: isize, usize</li>
</ul>
</li>
<li>Integer Literal:
<ul>
<li>Decimal: 98_222</li>
<li>Hex: 0xff</li>
<li>Octal: 0o77</li>
<li>Binary: 0b1111_0000</li>
<li>Byte (u8 only): b'A'</li>
</ul>
</li>
<li>Floating Point Types:
<ul>
<li>32 bit: f32</li>
<li>64 bit: f64</li>
<li>128 bit: f128</li>
<li>arch: fsize</li>
</ul>
</li>
<li>Boolean Types:
<ul>
<li>true, false</li>
</ul>
</li>
<li>Character Types:
<ul>
<li>Default: UTF-8 encoded</li>
</ul>
</li>
<li>Compound Types:
<ul>
<li>Tuple Type: <code>let tup: (i32, f64, u8) = (500, 6.4, 1);</code></li>
<li>Array Type: <code>let a = [1, 2, 3, 4, 5];</code></li>
</ul>
</li>
<li>Numeric Operations:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // remainder
    let remainder = 43 % 5;
}</code></pre></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}</code></pre></pre>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!(&quot;The measurement is: {value}{unit_label}&quot;);
}</code></pre></pre>
<h3 id="functions-with-return-value"><a class="header" href="#functions-with-return-value">Functions with Return Value</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {x}&quot;);
}</code></pre></pre>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<pre><pre class="playground"><code class="language-rust editable">// This is a comment
/** This is a comment **/
/// This is a special comment that gets used for documentation</code></pre></pre>
<h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<h3 id="if-expression"><a class="header" href="#if-expression">If expression</a></h3>
<ul>
<li>Rust has <code>if expressions</code></li>
<li>Rust <code>if</code> evaluations expect a <code>bool</code>, and integers will not be casted to bool.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">// If example
fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust should_panic editable">// If bool requirement
fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);
    }
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">// If-else example
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">// If expression example
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {number}&quot;);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust should_panic editable">// If expression all blocs should return the same value
fn main() {
    let condition = true;

    let number = if condition { 5 } else { &quot;six&quot; };

    println!(&quot;The value of number is: {number}&quot;);
}</code></pre></pre>
<h3 id="loops"><a class="header" href="#loops">Loops</a></h3>
<ul>
<li>Rust has loops.</li>
<li>Loops can be expressions.</li>
<li>It has <code>loop</code> for infinite loop.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {result}&quot;);
}</code></pre></pre>
<ul>
<li>It has <code>while</code> for predicate loop.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let top = 10;
    let mut counter = 0;
    while counter &lt; top {
	println!(&quot;Counter: {counter}&quot;);
	counter += 1;
    }
}
</code></pre></pre>
<ul>
<li>It has <code>for</code> for iterator loop.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let list = [0,1,2,3,4,5,6,7,8,9];
    for element in list {
	println!(&quot;Element: {element}&quot;);
    }
}
</code></pre></pre>
<ul>
<li>It has <code>break</code>, <code>label</code>, <code>continue</code> on blocks.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!(&quot;count = {count}&quot;);
        let mut remaining = 10;

        loop {
            println!(&quot;remaining = {remaining}&quot;);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(&quot;End count = {count}&quot;);
}
</code></pre></pre>
<h3 id="match-expression"><a class="header" href="#match-expression">Match Expression</a></h3>
<ul>
<li>Rust has <code>match expressions</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = true;

    let result = match x {
	true =&gt; &quot;It is True&quot;,
	false =&gt; &quot;It is False&quot;,
    };

    println!(&quot;Result: {result}&quot;);
}</code></pre></pre>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<ul>
<li>Rust contains both expressions and statements as a language. Example:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    }; // Expression

    println!(&quot;The value of y is: {y}&quot;);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 4; // Statement
    println!(&quot;The value of y is: {y}&quot;);
}</code></pre></pre>
<ul>
<li>Rust like any other language has reserve keywors, to learn more about the go here: <a href="https://doc.rust-lang.org/book/appendix-01-keywords.html">Keywords</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-borrowing"><a class="header" href="#ownership-and-borrowing">Ownership and Borrowing</a></h1>
<ul>
<li>Ownership and Borrowing are one of the core concepts that makes Rust unique.</li>
<li>Thanks to this concepts, Rust handles all of the memory management (allocation and deallocation) for the user with a guarantee that no data races will occur.</li>
</ul>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<ul>
<li>A set of rules that govern how a Rust program manages memory</li>
<li>The rules are:
<ul>
<li>Each value in Rust has an owner.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ul>
</li>
</ul>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &quot;Something&quot;.to_string();
let y = x; // Ownership of String &quot;Something&quot; is given to variable y.
println!(&quot;x: {}&quot;, x); // This will fail because x no longer is owner of &quot;Something&quot;.

<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> {                      // s is not valid here, it’s not yet declared
    let s = &quot;hello&quot;;   // s is valid from this point forward

    // do stuff with s
}                      // this scope is now over, and s is no longer valid
println!(&quot;s: {}&quot;, s); // This will fail because s is no longer in scope.
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust should_panic editable">
fn something(x: String) {
    println!(&quot;x: {}&quot;, x);
}

fn main() {
    let y = &quot;something&quot;.to_string();
    something(y); // y ownership is given to the function something.
    println!(&quot;y: {}&quot;, y); // This will fail because y no longer is owner of &quot;something&quot;.
}
</code></pre></pre>
<ul>
<li>As you can see Rust handled the allocation and deallocation of the variables thanks to the ownership system.</li>
</ul>
<h2 id="references-and-borrowing"><a class="header" href="#references-and-borrowing">References and Borrowing</a></h2>
<ul>
<li>A set of rules that govern how a Rust shares data.</li>
<li>The rules are:
<ul>
<li>A value can be shared with the following rules:
<ul>
<li>At any given time, you can have either one mutable reference or any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="immutable-references"><a class="header" href="#immutable-references">Immutable References</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1 = &quot;hello&quot;.to_string();

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
<p><img src="./imgs/trpl04-05.svg" alt="Memory" /></p>
<h3 id="mutable-references"><a class="header" href="#mutable-references">Mutable References</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust should_panic editable">    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);</code></pre></pre>
<pre><pre class="playground"><code class="language-rust should_panic editable">    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM

    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory"><a class="header" href="#memory">Memory</a></h1>
<h3 id="the-stack"><a class="header" href="#the-stack">The Stack</a></h3>
<ul>
<li>The stack is very fast, and is where memory is allocated in Rust by default. </li>
<li>But the allocation is local to a function call, and is limited in size.</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">fn foo() {
    println!(&quot;This is foo!&quot;);
}

fn main() {
    let x = 42; // This will be allocated in the stack.
    foo(); // This function stack will be allocated in the stack.
}
</code></pre></pre>
<h3 id="the-heap"><a class="header" href="#the-heap">The Heap</a></h3>
<ul>
<li>The heap, on the other hand, is slower, and is explicitly allocated by your program.</li>
<li>But it’s effectively unlimited in size, and is globally accessible. </li>
<li>Note this meaning of heap, which allocates arbitrary-sized blocks of memory in arbitrary order.</li>
<li>Values can be boxed (allocated on the heap) by creating a Box<T>. </li>
<li>A box is a smart pointer to a heap allocated value of type T. </li>
<li>When a box goes out of scope, its destructor is called, the inner object is destroyed, and the memory on the heap is freed.</li>
</ul>
<p>Boxed values can be dereferenced using the * operator; this removes one layer of indirection.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Box::new(5); // This will be allocated in the heap.
    let func: Box&lt;dyn Fn(usize)&gt; = Box::new(|x| {
        println!(&quot;x: {}&quot;, x);
    }); // This anonymous function will be stored in the heap.

    func(5); // The function will be run from the heap by a reference on the stack.
}
</code></pre></pre>
<script defer class="speakerdeck-embed" data-id="760299e421d649f985d5b04952dcc4f2" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<ul>
<li>A struct, or structure, is a custom data type that lets you package together and name multiple related values that make up a meaningful group.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">// Example of struct with name fields
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        // Example of field init
        email,
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = User {
        active: true,
        username: String::from(&quot;someusername123&quot;),
        email: String::from(&quot;someone@example.com&quot;),
        sign_in_count: 1,
    };

    let mut user2 = User {
        active: true,
        username: String::from(&quot;someusername456&quot;),
        email: String::from(&quot;someone@example.com&quot;),
        sign_in_count: 1,
    };

    user2.email = String::from(&quot;anotheremail@example.com&quot;);

    let user3 = build_user(String::from(&quot;someemail@example.com&quot;). String::from(&quot;ThisIsMe&quot;));

    // Creating Instances from Other Instances with Struct Update Syntax
    let user4 = User {
        username: String::from(&quot;someusername789&quot;),
        ..user3
    }
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Example of structs with anon fields
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Example of Unit Like structs
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Example of defining methods
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    pub fn new(width: u32, height: u32)-&gt; Self {
        Rectangle {
            width,
            height
        }
    }

    pub fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    pub fn is_square(&amp;self) -&gt; bool {
        self.width == self.height
    }
}

fn main() {
    let rec = Rectangle::new(2,3);
    let area = rec.area();
    let is_square = rec.is_square();
    println!(&quot;Rectangle area: {area}&quot;);
    println!(&quot;Rectangle is square: {is_square}&quot;);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-and-patterns"><a class="header" href="#enums-and-patterns">Enums and Patterns</a></h1>
<ul>
<li>Enums allow you to define a type by enumerating its possible variants.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">//Example simple enums
enum IpAddrKind {
    V4,
    V6,
}

fn route(ip_kind: IpAddrKind) {
    // do something
}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//Example enums with structs

enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from(&quot;127.0.0.1&quot;),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from(&quot;::1&quot;),
};
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of enums with fields
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));

<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of multiple enums definitions
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&amp;self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from(&quot;hello&quot;));
m.call();

<span class="boring">}</span></code></pre></pre>
<h2 id="patterns"><a class="header" href="#patterns">Patterns</a></h2>
<ul>
<li>Rust has an extremely powerful control flow construct called match that allows you to compare a value against a series of patterns and then execute code based on which pattern matches.</li>
<li>Matches are exhaustive</li>
<li>Matches can have a catch-all pattern</li>
<li>Matches are expressions</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    let result = match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        },
        // Catch all pattern
        _ =&gt; 0
    }

    println!(&quot;Result: {result}&quot;);
    result
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rust-doesnt-have-null-it-has-enums"><a class="header" href="#rust-doesnt-have-null-it-has-enums">Rust doesn't have null, it has enums</a></h2>
<ul>
<li>Rust doesn't have null, it uses the enum system to express something or nothing.</li>
<li>This simple concept solves the 1 trillion dollar mistake.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-generics-and-lifetime"><a class="header" href="#traits-generics-and-lifetime">Traits, Generics and Lifetime</a></h1>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
// fn largest&lt;T: Ord&gt;(list: &amp;[T]) -&gt; Option&lt;&amp;T&gt; {
//     list.iter().max()
// }

fn largest&lt;T:PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];
    list.

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Generic on functions
fn something&lt;T&gt;(ty:T) {}

// Generic on enums
enum Option&lt;T&gt; {
    Some(T),
    None,
}
enum Result&lt;T,E&gt; {
    Ok(T),
    Err(E)
}

// Generic on structs
struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

// Generic in methods definitions
impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Example of generic on each variable
struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c' };

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}</code></pre></pre>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<ul>
<li>Traits are like interfaces in other languages, but more powerful.</li>
<li>A trait defines functionality a particular type has and can share with other types. </li>
<li>We can use traits to define shared behavior in an abstract way.</li>
<li>We can use trait bounds to specify that a generic type can be any type that has certain behavior.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
    // With default implementation
        String::from(&quot;(Read more...)&quot;)
    }
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}

fn main() {
    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of traits depending on internal methods
pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of traits as parameters
pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of trait bound syntax
pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of trait bounds with where clause
fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
    42
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of returning types that implement traits
fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Complex example of using trait bounds to conditionally Implement Methods
use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h2>
<ul>
<li>Lifetimes is another kind of generics that it is used under the hood.</li>
<li>It is used by the rust compiler and borrow checker to validate the ownership,reference and borrowing rules.</li>
<li>Rust anotates scopes and variables with a given lifetime.</li>
</ul>
<pre><pre class="playground"><code class="language-rust should_panic">fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {}&quot;, r); //          |
}                         // ---------+

fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {}&quot;, r); //   |       |
                          // --+       |
}                         // ----------+</code></pre></pre>
<h3 id="lifetime-annotation-syntax"><a class="header" href="#lifetime-annotation-syntax">Lifetime annotation syntax</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lifetime annotations in function signatures
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// lifetime annotations in struct definitions
struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// the static lifetime
let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-language-features"><a class="header" href="#functional-language-features">Functional Language Features</a></h1>
<ul>
<li>Rust language design has taken inspiration from many functional programming languages and techniques.</li>
<li>This includes <code>closures</code>, treating classes as first class citizen, etc.</li>
<li>Rust been a zero cost abtraction language gives us the advantage that the high level description or code, doesn't affect performance, more on this later.</li>
</ul>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<pre><pre class="playground"><code class="language-rust">
fn sub_one(x:i32) -&gt; i32 {
    x - 1
}
fn main() {
    // closure that prints a text
    let print_text = || println!(&quot;Hello, World!&quot;);
    
    print_text(); 

    // Closure with parameter
    let add_one = |x| x + 1;
    let answer = add_one(41);
    println!(&quot;The answer to live is {answer}&quot;);

    // Assigning function to variable
    let operation = sub_one;

    let answer = operation(43);
    println!(&quot;The answer to live is {answer}&quot;);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Ways to define a function
fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of code failing because attempting to call a closure whose types are inferred with two different types
// Need to define type
let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Example of capturing reference
fn main() {
let list = vec![1, 2, 3];
println!(&quot;Before defining closure: {:?}&quot;, list);

let only_borrows = || println!(&quot;From closure: {:?}&quot;, list);

println!(&quot;Before calling closure: {:?}&quot;, list);
only_borrows();
println!(&quot;After calling closure: {:?}&quot;, list);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Example of capturing mutable reference
fn main() {
let mut list = vec![1, 2, 3];
println!(&quot;Before defining closure: {:?}&quot;, list);

let mut borrows_mutably = || list.push(7);

borrows_mutably();
println!(&quot;After calling closure: {:?}&quot;, list);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Example of moving ownership
use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {:?}&quot;, list);

    thread::spawn(move || println!(&quot;From thread: {:?}&quot;, list))
        .join()
        .unwrap();
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of Rust Optional unwrap or else complex moving capture values
impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Example of Rust list sorting
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!(&quot;{:#?}, sorted in {num_sort_operations} operations&quot;, list);
}</code></pre></pre>
<h2 id="iterator"><a class="header" href="#iterator">Iterator</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of iterator
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;Got: {}&quot;, val);
}

<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Example iterator next
pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}

fn main() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;3));
    assert_eq!(v1_iter.next(), None);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Example of chaining methods that consume iterators
fn main() {
    let v1 = vec![1, 2, 3];

    let total: i32 = v1.iter().sum();

    assert_eq!(total, 6);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// Example of methods that produce other iterators
fn main() {
    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn iterator() -&gt; Vec&lt;i32&gt;{
    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1).collect()
}

fn transform() -&gt; Vec&lt;i32&gt;{
    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    {
        let mut result: Vec&lt;_&gt; = Vec::new();
        let map = |x:i32| x + 1;
        for v in v1 {
            result.push(map(v));
        }

        result
    }
}

fn main() {
    let i = iterator();
    let t = transform();
    println!(&quot;Iterator: {:?}&quot;, i);
    println!(&quot;Transform: {:?}&quot;, t);
}
</code></pre></pre>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html">Iterator</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections"><a class="header" href="#collections">Collections</a></h1>
<ul>
<li>Rust’s standard library includes a number of very useful data structures called collections. <a href="https://doc.rust-lang.org/std/collections/index.html">Collection Standard Library</a></li>
<li>Rust most common collections are <code>vector</code>(similar to array or list on other languages), <code>string</code>, and <code>map</code>, but there are many more.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Immutable
let v: Vec&lt;i32&gt; = Vec::new();
// Macro
let v = vec![1, 2, 3];
// Mutable
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> // Example of reading vector
 let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
println!(&quot;The third element is {third}&quot;);

let third: Option&lt;&amp;i32&gt; = v.get(2);
match third {
    Some(third) =&gt; println!(&quot;The third element is {third}&quot;),
    None =&gt; println!(&quot;There is no third element.&quot;),
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of bad logic
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);

<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of ownership with vectors
let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);

println!(&quot;The first element is: {first}&quot;);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of iterating over vector
let v = vec![100, 32, 57];

for i in &amp;v {
    println!(&quot;{i}&quot;);
}

for i in v.iter() {
    println!(&quot;{i}&quot;);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Using enums to store multiple types
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// How vector drops its elements
{
    let v = vec![1, 2, 3, 4];

    // do stuff with v
} // &lt;- v goes out of scope and is freed here
// Drop happens from first to last element, aka from left to right
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<ul>
<li>Errors are part of life, Rust uses the <code>Result&lt;T,E&gt;</code> to handle recoverable errors and the macro <code>panic!()</code> for unrecoverable errors.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">use std::fs::File;

fn main() { 
    let greeting_file_result = File::open(&quot;hello.txt&quot;);
    println!(&quot;{:?}&quot;, greeting_file_result);

    // let greeting_file = match greeting_file_result {
    //     Ok(file) =&gt; file,
    //     Err(error) =&gt; panic!(&quot;Problem opening the file: {:?}&quot;, error),
    // };

    // let result = greeting_file_result.expect(&quot;hello.txt should be included in this project&quot;);
    //let file = greeting_file_result?;

    //... process file result;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointer"><a class="header" href="#smart-pointer">Smart Pointer</a></h1>
<ul>
<li>Smart pointers are data structures that act like a pointer but also have additional metadata and capabilities.</li>
<li>Rust has a variety of smart pointers defined in the standard library that provide functionality beyond that provided by references.</li>
<li>Example of Rust smart pointers:
<ul>
<li>Box<T> for allocating values on the heap</li>
<li>Rc<T>, a reference counting type that enables multiple ownership</li>
<li>Ref<T> and RefMut<T>, accessed through RefCell<T>, a type that enforces the borrowing rules at runtime instead of compile time</li>
</ul>
</li>
</ul>
<h2 id="box"><a class="header" href="#box">Box<T></a></h2>
<pre><pre class="playground"><code class="language-rust">// Example of rust
fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">}</span></code></pre></pre>
<p><img src="./imgs/trpl15-01.svg" alt="List" /></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}
<span class="boring">}</span></code></pre></pre>
<p><img src="./imgs/trpl15-02.svg" alt="List" /></p>
<pre><pre class="playground"><code class="language-rust">// Deref with *
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}</code></pre></pre>
<h2 id="rc"><a class="header" href="#rc">Rc<T></a></h2>
<ul>
<li>The reference counter smart pointer
<img src="./imgs/trpl15-03.svg" alt="List" /></li>
</ul>
<pre><pre class="playground"><code class="language-rust should_panic">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre></pre>
<h1 id="ref-refmut-and-refcell"><a class="header" href="#ref-refmut-and-refcell">Ref<T>, RefMut<T> and RefCell<T></a></h1>
<ul>
<li>Interior mutability is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules.</li>
<li>To mutate data, the pattern uses <code>unsafe</code> code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing.</li>
<li>This smart pointer enforce the borrowing rules at runtime.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<ul>
<li>Rust has two types of macros, this are: declaritive macros and procedural marcros.</li>
<li>Declarative macros are defined within the <code>macro_rules!</code> macro. Example of this are <code>println!</code>, <code>vec!</code>, etc.</li>
<li>Procedural macros can be defined as 3 types, and this are:
<ul>
<li>Custom <code>#[derive]</code> macros</li>
<li>Attribute like macros</li>
<li>Function like macros</li>
</ul>
</li>
<li>Macros are Rust way of metaprogramming (aka code writing code).</li>
<li>More information <a href="https://danielkeep.github.io/tlborm/book/index.html">here</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<ul>
<li>Rust has testing ingrained inside the language, this means that Rust at its core has its own testing framework or methodology similar to Rust.</li>
<li>Rust by default uses its derive macro to define a test profile for compiling and running tests.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module-crates-and-packages"><a class="header" href="#module-crates-and-packages">Module, Crates and Packages</a></h1>
<ul>
<li>Package is your project.</li>
<li>Crates are dependencies.</li>
<li>Modules are internal packages inside your project structure.</li>
<li>Use project to present <code>modules</code>, <code>crates</code> and <code>packages</code>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
